 ## new、delete、malloc、free关系：

me：new和delete匹配，malloc和free匹配。都是动态申请内存，要手动释放。通过new的会调用到构造函数，delete会调用到析构函数。  
补充：malloc/free是库函数而非运算符。new能完成动态内存分配和初始化工作，delete能完成清理与释放内存工作，他们并非库函数。

## c和c++的不同之处  

me：c++是一个集合，包括c、模板以及类的扩充。即是包含面向过程和面向对象的思想的一个集合。  
补充：  


## 引用和指针的区别  

me：引用必须要显式初始化，是指变量的别名而非变量。而指针指向的是变量的地址，指针本身是变量(他们有自己的地址)。指针可以改变指向对象，引用是不可改变的。  
补充：引用跟原来的变量实质上是一个东西，**在内存占有同一个存储单元**

## 面向对象特点  

me：
封装：即把一些东西抽象出来成为一个类，一个整体，其中包括他的所有特点和属性。

继承：通过继承可以继承到父类的成员变量和成员函数，也可以覆盖父类的方法。  

多态：在运行时进行变化，即同一个函数(*在父类加上virtual关键字*)会根据实际类型调用到对应的函数，在指针是基类指针的情况下。

补充：
+ 封装可以使得代码模块化，继承可以拓展已经存在的代码，他们的目的都是为了代码重用。多态的目的是为了接口重用。
+ 多态与非多态的实质区别就是函数地址是**早绑定还是晚绑定**。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要**在运行时**才确定，这就属于晚绑定。

## 常量const和define
me：nothing...  
补充：
+ 编译器处理方式：define在预处理阶段进行替换；const在编译时确定其值
+ 类型检查：define无类型，不进行类型安全检查，可能会产生意想不到的错误；const有数据类型，编译时会进行类型检查。
+ 内存空间： define不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大；const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。
+ 其他： 在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。   
define替换只作替换，不做计算，不做表达式求解。  
宏定义的作用范围仅限于当前文件。   
默认状态下，const对象只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。   
如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字（在声明和定义时都要加）。

>规则 
在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。

## const用法
me:
+ 全局常量
+ 形参中使用const&，可以使得参数不被修改且提高运行效率,因为是引用，且可以支持的参数类型更多(常量类)
+ 成员函数const，在函数体内部，不可进行函数成员的更改。
补充：

## overload(重载)、override(覆盖)、overwrite(重写)
me:
+ 重载发生于同一个类中(或者全局重载），重载的函数名相同，形参不同。
+ 覆盖发生于基类和子类中，必须是虚函数(virtual)，且函数名和形参等完全一样
+ 重写即函数名相同。
补充：
+ 重写：基类和子类函数同名，若参数不同(包括返回值)，不管基类有无virtual都算重写。若参数相同，有virual则算是覆盖，无则算重写。

## c++是不是类型安全的
me：what？  
补充： 不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。